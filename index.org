#+Title: Fold
#+Author: Tim Heaney
#+Email: theaney@gmail.com

* Fold                                                                :slide:

- Fold is a fundamental recursive function. It has many names
  + [[https://en.wikipedia.org/wiki/Fold_%28higher-order_function%29][fold]] 
  + reduce
  + inject
  + Lit
  + ...
- Any [[https://en.wikipedia.org/wiki/Primitive_recursive_function][primitive recursive function]] can be written as a fold.
- A [[https://en.wikipedia.org/wiki/Fixed_point_combinator][fixed point combinator]] can be implemented with fold.

* fold                                                                :slide:

- *fold* is a whole family of functions
- finite or infinite
- eager or lazy
- left- or right-associative (~foldl~, ~foldr~)
  + Elm has ~foldp~ ("fold from the past")
  + Spark has ~foldByKey~
- List folds, tree folds, general folds
- catamorphism \colon fold \colon\colon anamorphism \colon unfold

* Elixir example                                                      :slide:

#+BEGIN_SRC 
iex> Enum.sum [1, 2, 3, 4]    
10
iex> Enum.reduce [1, 2, 3, 4], 0, &(&1 + &2)
10
iex> List.foldl [1, 2, 3, 4], 0, &(&1 + &2) 
10
iex> List.foldr [1, 2, 3, 4], 0, &(&1 + &2)
10
iex> Enum.scan 1..4, 0, &(&1 + &2)                
[1, 3, 6, 10]
iex> Enum.to_list(Stream.scan 1..4, 0, &(&1 + &2))  
[1, 3, 6, 10]

#+END_SRC

* associativity                                                       :slide:

- ~foldl~ -> ((1 + 2) + 3)+ 4
- ~foldr~ -> 1 + (2 + (3 + 4))

* Haskell type notation                                               :slide:

#+BEGIN_SRC haskell
foldl :: (b -> a -> b) -> b -> List a -> b

foldr :: (a -> b -> b) -> b -> List a -> b

#+END_SRC

* Haskell recursive definition of foldl                               :slide:

#+BEGIN_SRC haskell
foldl :: (b -> a -> b) -> b -> [a] -> b

foldl f z [] = z
foldl f z (x:xs) = foldl f (f z x) xs

#+END_SRC


* Haskell recursive definition of foldr                               :slide:

#+BEGIN_SRC haskell
foldr :: (a -> b -> b) -> b -> [a] -> b

foldr f z [] = z
foldr f z (x:xs) = f x (foldr f z xs)

#+END_SRC

(not tail recursive)


* cons lists                                                          :slide:

- sequence of cons cells (ending in nil)
- 1:2:3:4:[]

* lazy lists                                                          :slide:

- sequence of cons cells
- 1:2:3:...
- How do we start at the right?

* foldl does a for loop                                               :slide:

~foldl(f, v, xs)~

#+BEGIN_SRC python
r = v
for e in xs:
    r = f(r, e)
return r

#+END_SRC

it cannot work on an infinite list

* foldr peforms constructor replacement                               :slide:

~foldr(f, v, xs)~

1. replace /every/ occurrence of ~cons~ with ~f~
1. replace /any/ occurrence of ~nil~ with ~v~

if ~nil~ is absent, we have an infinite list

* Elm example                                                         :slide:

- Elm shows this difference nicely
- It has both ~List.foldl~ and ~List.foldr~
- We can use Debug to see what it's doing

* Elm example                                                         :slide:

#+BEGIN_SRC
$ elm-repl

> List.foldl (+) 0 [1,2,3,4]
10 : number

> List.foldr (+) 0 [1,2,3,4]
10 : number

#+END_SRC

* Elm example                                                         :slide:

#+BEGIN_SRC
> List.foldl (\a b -> a + b ) 0 [1,2,3,4]
10 : number

> List.foldr (\a b -> a + b ) 0 [1,2,3,4]
10 : number

#+END_SRC

* Elm example                                                         :slide:

#+BEGIN_SRC
> List.foldl (\a b -> a + b |> Debug.log ((toString a)++" + "++(toString b))) 0 [1,2,3,4]
1 + 0: 1
2 + 1: 3
3 + 3: 6
4 + 6: 10
10
    : number

> List.foldr (\a b -> a + b |> Debug.log ((toString a)++" + "++(toString b))) 0 [1,2,3,4]
4 + 0: 4
3 + 4: 7
2 + 7: 9
1 + 9: 10
10
    : number

#+END_SRC

* Re-writing things with foldr                                        :slide:
#+BEGIN_SRC
$ elm-repl 
> import List exposing (foldr)

#+END_SRC

* Sum of a list                                                       :slide:
#+BEGIN_SRC
> sum xs = foldr (+) 0 xs
<function> : List number -> number

> sum [1,2,3,4]
10 : number

#+END_SRC

* Product of a list                                                   :slide:
#+BEGIN_SRC
> product xs = foldr (*) 1 xs
<function> : List number -> number

> product [1,2,3,4]
24 : number

#+END_SRC

* Length of a list                                                    :slide:
#+BEGIN_SRC
> length xs = foldr (\x y -> 1 + y) 0 xs
<function> : List a -> number

> length [1,2,3,4]
4 : number

> length []
0 : number

> length [1,2,3,9,0]
5 : number

#+END_SRC

* Boolean tests                                                       :slide:
#+BEGIN_SRC
> all p xs = foldr (\x y -> (p x) && y) True xs
<function> : (a -> Bool) -> List a -> Bool

> all (\x -> x > 5) [1,2,3,4]
False : Bool

> all (\x -> x < 5) [1,2,3,4]
True : Bool

#+END_SRC

* Boolean tests                                                       :slide:
#+BEGIN_SRC
> any p xs = foldr (\x y -> (p x) || y) False xs
<function> : (a -> Bool) -> List a -> Bool

> any (\x -> x < 3) [1,2,3,4]
True : Bool

> any (\x -> x > 5) [1,2,3,4]
False : Bool

#+END_SRC

* Reverse a list                                                      :slide:

- List append in Elm is ++
#+BEGIN_SRC
> reverse xs = foldr (\x y -> y ++ [x]) [] xs
<function> : List a -> List a

> reverse [1,2,3,4]
[4,3,2,1] : List number

#+END_SRC

* Map a function to a list                                            :slide:

- List cons in Elm is \colon\colon
#+BEGIN_SRC
> map f xs = foldr (\x y -> f x :: y) [] xs
<function> : (a -> b) -> List a -> List b

> map (\x -> x + 10) [1,2,3,4]
[11,12,13,14] : List number

#+END_SRC

* reduce                                                              :slide:

- Clojure (like many other languages) has ~reduce~
- This is the same as ~foldl~

#+BEGIN_SRC clojure
(reduce + [1 2 3 4])
#+END_SRC

* Defining folds in Clojure                                           :slide:

#+BEGIN_SRC clojure
(defn foldl [f val coll]
  (if (empty? coll) val
    (foldl f (f val (first coll)) (rest coll))))

(defn foldr [f val coll]
  (if (empty? coll) val
    (f (foldr f val (rest coll)) (first coll))))

#+END_SRC

* Clojure Example                                                     :slide:

#+BEGIN_SRC
user=> (+ 1 2 3 4)
10
user=> (reduce + [1 2 3 4])
10
user=> (foldl + 0 [1 2 3 4])
10
user=> (foldr + 0 [1 2 3 4])
10

#+END_SRC

* Clojure reducers and transducers                                    :slide:

- https://clojuredocs.org/clojure.core.reducers/fold
- https://clojure.org/reference/transducers

* Reference (paper)                                                   :slide:

- Graham Hutton
- A tutorial on the universality and expressiveness of fold
- Journal of Functional Programming, July 1999
- [[http://www.cs.nott.ac.uk/~pszgmh/fold.pdf][fold.pdf]]

* Reference (talk)                                                    :slide:

- Tony Morris
- Explain List Folds to Yourself
- Brisbane Functional Programming Group, 23 April 2013
- [[http://blog.tmorris.net/posts/list-folds-bfpg/index.html][List Folds at BFPG]]

* Contact                                                             :slide:

- @oylenshpeegul
- oylenshpeegul@gmail.com


#+OPTIONS: num:nil tags:t

#+TAGS: slide(s)

#+HTML_HEAD_EXTRA: <link rel="stylesheet" type="text/css" href="common.css" />
#+HTML_HEAD_EXTRA: <link rel="stylesheet" type="text/css" href="screen.css" media="screen" />
#+HTML_HEAD_EXTRA: <link rel="stylesheet" type="text/css" href="projection.css" media="projection" />
#+HTML_HEAD_EXTRA: <link rel="stylesheet" type="text/css" href="presenter.css" media="presenter" />

#+BEGIN_EXPORT html
<script type="text/javascript" src="org-html-slideshow.js"></script>
#+END_EXPORT

# Local Variables:
# org-html-head-include-default-style: nil
# org-html-head-include-scripts: nil
# End:
